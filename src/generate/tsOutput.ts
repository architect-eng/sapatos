

import * as pg from 'pg';
import type { SchemaVersionCanary } from "../db/canary";
import type { CompleteConfig } from './config';
import { enumDataForSchema, enumTypesForEnumData } from './enums';
import { header } from './header';
import {
  RelationData,
  relationsInSchema,
  dataForRelationInSchema,
  structureMapEntryForRelation,
  namespaceAliasForRelation,
  sqlExpressionTypeForRelation,
} from './tables';


export interface CustomTypes {
  [name: string]: string;  // any, or TS type for domain's base type
}

const
  canaryVersion: SchemaVersionCanary['version'] = 104,
  versionCanary = `
// got a type error on schemaVersionCanary below? update by running \`npx sapatos\`
export interface schemaVersionCanary extends db.SchemaVersionCanary { version: ${String(canaryVersion)} }
`;

const declareModule = (module: string, declarations: string) => `
declare module '${module}' {
${declarations.replace(/^(?=[ \t]*\S)/gm, '  ')}
}
`;

const customTypeHeader = `/*
** Please edit this file as needed **
It's been generated by Sapatos as a custom type definition placeholder, and won't be overwritten
*/
`;

const sourceFilesForCustomTypes = (customTypes: CustomTypes) =>
  Object.fromEntries(Object.entries(customTypes)
    .map(([name, baseType]) => [
      name,
      customTypeHeader + declareModule('sapatos/custom',
        (baseType === 'db.JSONValue' ? `import type * as db from 'sapatos/db';\n` : ``) +
        `export type ${name} = ${baseType};  // replace with your custom type or interface as desired`
      )
    ]));

export const tsForConfig = async (config: CompleteConfig, debug: (s: string) => void) => {
  let querySeq = 0;
  const
    { schemas, db } = config,
    pool = new pg.Pool(db),
    queryFn = async (query: pg.QueryConfig, seq = querySeq++) => {
      try {
        debug(`>>> query ${String(seq)} >>>\n${query.text.replace(/^\s+|\s+$/mg, '')}\n+ ${JSON.stringify(query.values)}\n`);
        const result = await pool.query(query);
        debug(`<<< result ${String(seq)} <<<\n${JSON.stringify(result, null, 2)}\n`);
        return result;

      } catch (e) {
        console.log(`*** error ${String(seq)} ***`, e);
        process.exit(1);
      }
    },
    customTypes = {},
    schemaNames = Object.keys(schemas),
    schemaData = (await Promise.all(
      schemaNames.map(async schema => {
        const rules = schemas[schema];
        if (rules === undefined) throw new Error(`No rules found for schema: ${schema}`);
        const
          tables = rules.exclude === '*' ? [] :  // exclude takes precedence
            (await relationsInSchema(schema, queryFn))
              .filter(rel => rules.include === '*' || rules.include.indexOf(rel.name) >= 0)
              .filter(rel => rules.exclude.indexOf(rel.name) < 0),
          enums = await enumDataForSchema(schema, queryFn),
          tableData = await Promise.all(tables.map(async table =>
            dataForRelationInSchema(table, schema, enums, customTypes, config, queryFn)));

        return { schema, tables, tableData, enums };
      }))
    ),
    allTableData = ([] as RelationData[]).concat(...schemaData.map(r => r.tableData)),
    hasCustomTypes = Object.keys(customTypes).length > 0;

  // Generate StructureMap entries
  const structureMapEntries = allTableData.map(data => structureMapEntryForRelation(data)).join('\n');

  // Generate SQLExpression types (needed by StructureMap)
  const sqlExpressionTypes = allTableData.map(data => sqlExpressionTypeForRelation(data)).join('\n  ');

  // Generate namespace aliases (for backward compatibility)
  const namespaceAliases = allTableData.map(data => namespaceAliasForRelation(data)).join('\n\n');

  // Generate enum types (only if there are actual enums)
  const enumTypes = schemaData
    .map(({ enums }) => Object.keys(enums).length > 0 ? enumTypesForEnumData(enums) : '')
    .filter(s => s.trim().length > 0)
    .join('\n\n');

  // Generate lookup types
  const lookupTypes = `
export type SelectableForTable<T extends Table> = StructureMap[T]['Selectable'];

export type JSONSelectableForTable<T extends Table> = StructureMap[T]['JSONSelectable'];

export type WhereableForTable<T extends Table> = StructureMap[T]['Whereable'];

export type InsertableForTable<T extends Table> = StructureMap[T]['Insertable'];

export type UpdatableForTable<T extends Table> = StructureMap[T]['Updatable'];

export type UniqueIndexForTable<T extends Table> = StructureMap[T]['UniqueIndex'];

export type ColumnForTable<T extends Table> = StructureMap[T]['Column'];

export type SQLForTable<T extends Table> = StructureMap[T]['SQL'];
`;

  // Generate union types
  const unionTypes = `
export type Table = keyof StructureMap;
export type Selectable = StructureMap[Table]['Selectable'];
export type JSONSelectable = StructureMap[Table]['JSONSelectable'];
export type Whereable = StructureMap[Table]['Whereable'];
export type Insertable = StructureMap[Table]['Insertable'];
export type Updatable = StructureMap[Table]['Updatable'];
export type UniqueIndex = StructureMap[Table]['UniqueIndex'];
export type Column = StructureMap[Table]['Column'];
`;

  const ts = header() + declareModule('sapatos/schema',
    `\nimport type * as db from 'sapatos/db';\n` +
    (hasCustomTypes ? `import type * as c from 'sapatos/custom';\n` : ``) +
    versionCanary + '\n\n' +
    (enumTypes ? `/* --- enums --- */\n${enumTypes}\n\n` : '') +
    `/* --- SQLExpression helper types --- */\n` +
    sqlExpressionTypes + '\n\n' +
    `/* --- StructureMap --- */\n` +
    `interface StructureMap {\n` +
    structureMapEntries + '\n' +
    `}\n\n` +
    `/* --- Union types --- */\n` +
    unionTypes + '\n\n' +
    `/* --- Lookup types --- */\n` +
    lookupTypes + '\n\n' +
    `/* --- Backward compatible namespace aliases --- */\n` +
    namespaceAliases
  );

  const customTypeSourceFiles = sourceFilesForCustomTypes(customTypes);

  await pool.end();
  return { ts, customTypeSourceFiles };
};
