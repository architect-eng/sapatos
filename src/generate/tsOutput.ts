

import * as pg from 'pg';
import type { SchemaVersionCanary } from "../db/canary";
import type { CompleteConfig } from './config';
import { CustomTypes, CustomTypeRegistry } from './customTypes';
import { createQueryFunction, createDebugLogger, createExitOnErrorHandler } from './database';
import { enumDataForSchema, enumTypesForEnumData } from './enums';
import { header } from './header';
import {
  RelationData,
  relationsInSchema,
  dataForRelationInSchema,
  structureMapEntryForRelation,
  schemaNamespacesForAllRelations,
  sqlExpressionTypeForRelation,
} from './tables';

const
  canaryVersion: SchemaVersionCanary['version'] = 105,
  versionCanary = `
// got a type error on schemaVersionCanary below? update by running \`npx @architect-eng/sapatos\`
export interface schemaVersionCanary extends db.SchemaVersionCanary { version: ${String(canaryVersion)} }
`;

const declareModule = (module: string, declarations: string) => `
declare module '${module}' {
${declarations.replace(/^(?=[ \t]*\S)/gm, '  ')}
}
`;

const customTypeHeader = `/*
** Please edit this file as needed **
It's been generated by Sapatos as a custom type definition placeholder, and won't be overwritten
*/
`;

const sourceFilesForCustomTypes = (customTypes: CustomTypes) =>
  Object.fromEntries(Object.entries(customTypes)
    .map(([name, baseType]) => [
      name,
      customTypeHeader + declareModule('@architect-eng/sapatos/custom',
        (baseType === 'db.JSONValue' ? `import type * as db from '@architect-eng/sapatos/db';\n` : ``) +
        `export type ${name} = ${baseType};  // replace with your custom type or interface as desired`
      )
    ]));

export const tsForConfig = async (
  config: CompleteConfig,
  debug: (s: string) => void,
  existingPool?: pg.Pool
) => {
  const
    { schemas, db } = config,
    pool = existingPool ?? new pg.Pool(db),
    shouldClosePool = !existingPool,
    debugLogger = createDebugLogger(debug),
    queryFn = createQueryFunction(pool, {
      onQueryStart: debugLogger.onQueryStart,
      onQueryComplete: debugLogger.onQueryComplete,
      onQueryError: createExitOnErrorHandler(),
    }),
    registry = new CustomTypeRegistry(),
    schemaNames = Object.keys(schemas),
    schemaData = (await Promise.all(
      schemaNames.map(async schema => {
        const rules = schemas[schema];
        if (rules === undefined) throw new Error(`No rules found for schema: ${schema}`);
        const
          tables = rules.exclude === '*' ? [] :  // exclude takes precedence
            (await relationsInSchema(schema, queryFn))
              .filter(rel => rules.include === '*' || rules.include.indexOf(rel.name) >= 0)
              .filter(rel => rules.exclude.indexOf(rel.name) < 0),
          enums = await enumDataForSchema(schema, queryFn),
          tableData = await Promise.all(tables.map(async table =>
            dataForRelationInSchema(table, schema, enums, registry, config, queryFn)));

        return { schema, tables, tableData, enums };
      }))
    ),
    allTableData = ([] as RelationData[]).concat(...schemaData.map(r => r.tableData)),
    customTypes = registry.getRegisteredTypes(),
    hasCustomTypes = Object.keys(customTypes).length > 0;

  // Generate StructureMap entries
  const structureMapEntries = allTableData.map(data => structureMapEntryForRelation(data)).join('\n');

  // Generate SQLExpression types (needed by StructureMap)
  const sqlExpressionTypes = allTableData.map(data => sqlExpressionTypeForRelation(data)).join('\n  ');

  // Generate namespace aliases (for backward compatibility, grouped by schema)
  const namespaceAliases = schemaNamespacesForAllRelations(allTableData, config.unprefixedSchema);

  // Generate enum types (only if there are actual enums)
  const enumTypes = schemaData
    .map(({ enums }) => Object.keys(enums).length > 0 ? enumTypesForEnumData(enums) : '')
    .filter(s => s.trim().length > 0)
    .join('\n\n');

  // Generate lookup types
  const lookupTypes = `
export type SelectableForTable<T extends Table> = StructureMap[T]['Selectable'];

export type JSONSelectableForTable<T extends Table> = StructureMap[T]['JSONSelectable'];

export type WhereableForTable<T extends Table> = StructureMap[T]['Whereable'];

export type InsertableForTable<T extends Table> = StructureMap[T]['Insertable'];

export type UpdatableForTable<T extends Table> = StructureMap[T]['Updatable'];

export type UniqueIndexForTable<T extends Table> = StructureMap[T]['UniqueIndex'];

export type ColumnForTable<T extends Table> = StructureMap[T]['Column'];

export type SQLForTable<T extends Table> = StructureMap[T]['SQL'];
`;

  // Generate union types
  const unionTypes = `
export type Table = keyof StructureMap;
export type Selectable = StructureMap[Table]['Selectable'];
export type JSONSelectable = StructureMap[Table]['JSONSelectable'];
export type Whereable = StructureMap[Table]['Whereable'];
export type Insertable = StructureMap[Table]['Insertable'];
export type Updatable = StructureMap[Table]['Updatable'];
export type UniqueIndex = StructureMap[Table]['UniqueIndex'];
export type Column = StructureMap[Table]['Column'];
`;

  const ts = header() + declareModule('@architect-eng/sapatos/schema',
    `\nimport type * as db from '@architect-eng/sapatos/db';\n` +
    (hasCustomTypes ? `import type * as c from '@architect-eng/sapatos/custom';\n` : ``) +
    versionCanary + '\n\n' +
    (enumTypes ? `/* --- enums --- */\n${enumTypes}\n\n` : '') +
    `/* --- SQLExpression helper types --- */\n` +
    sqlExpressionTypes + '\n\n' +
    `/* --- StructureMap --- */\n` +
    `interface StructureMap {\n` +
    structureMapEntries + '\n' +
    `}\n\n` +
    `/* --- Union types --- */\n` +
    unionTypes + '\n\n' +
    `/* --- Lookup types --- */\n` +
    lookupTypes + '\n\n' +
    `/* --- Backward compatible namespace aliases --- */\n` +
    namespaceAliases
  );

  const customTypeSourceFiles = sourceFilesForCustomTypes(customTypes);

  // Only close the pool if we created it (not if we're reusing an existing one)
  if (shouldClosePool) {
    await pool.end();
  }
  return { ts, customTypeSourceFiles };
};
