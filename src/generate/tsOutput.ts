

import * as pg from 'pg';
import type { SchemaVersionCanary } from "../db/canary";
import type { CompleteConfig } from './config';
import { enumDataForSchema, enumTypesForEnumData } from './enums';
import { header } from './header';
import {
  Relation,
  relationsInSchema,
  domainsInSchema,
  definitionForRelationInSchema,
  crossTableTypesForTables,
  crossSchemaTypesForAllTables,
  crossSchemaTypesForSchemas,
  generateSchemaInterface,
  sanitizeNamespaceIdentifier,
} from './tables';


/**
 * Information about a custom type.
 */
export interface CustomTypeInfo {
  /** The TypeScript type (e.g., 'string', '[string, string]', 'any') */
  tsType: string;
  /** If this is a domain, the base type it references (e.g., 'PgTypeid') */
  baseTypeRef?: string;
  /** If true, this is a base type mapping from config (not a domain) */
  isBaseTypeMapping?: boolean;
}

export interface CustomTypes {
  [name: string]: string | CustomTypeInfo;  // string for backward compatibility, or object for new format
}

const
  canaryVersion: SchemaVersionCanary['version'] = 105,
  versionCanary = `
// got a type error on schemaVersionCanary below? update by running \`npx @architect-eng/sapatos\`
export interface schemaVersionCanary extends db.SchemaVersionCanary { version: ${String(canaryVersion)} }
`;

const customTypeHeader = `/*
** Please edit this file as needed **
It's been generated by Sapatos as a custom type definition placeholder, and won't be overwritten
*/
`;

export const sourceFilesForCustomTypes = (customTypes: CustomTypes) =>
  Object.fromEntries(Object.entries(customTypes)
    .map(([name, info]) => {
      // Handle both old string format and new object format
      const typeInfo: CustomTypeInfo = typeof info === 'string'
        ? { tsType: info }
        : info;

      let content = customTypeHeader;

      if (typeInfo.baseTypeRef !== undefined && typeInfo.baseTypeRef !== '') {
        // Domain referencing a base type
        content += `import type { ${typeInfo.baseTypeRef} } from './${typeInfo.baseTypeRef}';\n`;
        // Extract original type name from prefixed name (e.g., 'PgTypeid' -> 'typeid')
        const originalTypeName = typeInfo.baseTypeRef.replace(/^Pg/, '').toLowerCase();
        // Use tsType for the export (which may include [] for arrays)
        content += `export type ${name} = ${typeInfo.tsType};  // domain based on ${originalTypeName}\n`;
      } else if (typeInfo.isBaseTypeMapping === true) {
        // Base type mapping from config
        content += typeInfo.tsType === 'db.JSONValue'
          ? `import type * as db from '@architect-eng/sapatos/db';\n`
          : ``;
        content += `export type ${name} = ${typeInfo.tsType};  // base type mapping from config\n`;
      } else {
        // Standard custom type (existing behavior)
        content += typeInfo.tsType === 'db.JSONValue'
          ? `import type * as db from '@architect-eng/sapatos/db';\n`
          : ``;
        content += `export type ${name} = ${typeInfo.tsType};  // replace with your custom type or interface as desired\n`;
      }

      return [name, content];
    }));

export const generateBarrelContent = (customTypeNames: string[]) =>
  customTypeNames
    .map(name => `export * from './${name}';`)
    .join('\n') + (customTypeNames.length > 0 ? '\n' : '');

export function indentAll(level: number, s: string) {
  if (level === 0) return s;
  return s.replace(/^/gm, ' '.repeat(level));
}

export const tsForConfig = async (config: CompleteConfig, debug: (s: string) => void) => {
  let querySeq = 0;
  const
    { schemas, db } = config,
    pool = new pg.Pool(db),
    queryFn = async (query: pg.QueryConfig, seq = querySeq++) => {
      try {
        debug(`>>> query ${String(seq)} >>>\n${query.text.replace(/^\s+|\s+$/mg, '')}\n+ ${JSON.stringify(query.values)}\n`);
        const result = await pool.query(query);
        debug(`<<< result ${String(seq)} <<<\n${JSON.stringify(result, null, 2)}\n`);
        return result;

      } catch (e) {
        console.log(`*** error ${String(seq)} ***`, e);
        process.exit(1);
      }
    },
    customTypes = {},
    schemaNames = Object.keys(schemas),
    schemaData = (await Promise.all(
      schemaNames.map(async schema => {
        const rules = schemas[schema];
        if (rules === undefined) throw new Error(`No rules found for schema: ${schema}`);
        const
          tables = rules.exclude === '*' ? [] :  // exclude takes precedence
            (await relationsInSchema(schema, queryFn))
              .filter(rel => rules.include === '*' || rules.include.indexOf(rel.name) >= 0)
              .filter(rel => rules.exclude.indexOf(rel.name) < 0),
          enums = await enumDataForSchema(schema, queryFn),
          domains = await domainsInSchema(schema, queryFn),
          tableDefs = await Promise.all(tables.map(async table =>
            definitionForRelationInSchema(table, schema, enums, customTypes, config, queryFn, domains))),
          schemaIsUnprefixed = schema === config.unprefixedSchema,
          sanitizedSchema = sanitizeNamespaceIdentifier(schema),
          none = '/* (none) */',
          schemaDef = `/* === schema: ${schema} === */\n` +
            (schemaIsUnprefixed ? '' : `\nexport namespace ${sanitizedSchema} {\n`) +
            indentAll(schemaIsUnprefixed ? 0 : 2,
              `\n/* --- enums --- */\n` +
              (enumTypesForEnumData(enums) || none) +
              `\n\n/* --- tables --- */\n` +
              (tableDefs.join('\n') || none) +
              `\n\n/* --- aggregate types --- */\n` +
              (schemaIsUnprefixed ?
                `\nexport namespace ${sanitizedSchema} {` + (indentAll(2, crossTableTypesForTables(tables) || none)) + '\n}\n' :
                (crossTableTypesForTables(tables) || none))
            ) + '\n' +
            (schemaIsUnprefixed ? '' : `}\n`);

        return { schemaDef, tables };
      }))
    ),
    schemaDefs = schemaData.map(r => r.schemaDef),
    schemaTables = schemaData.map(r => r.tables),
    allTables = ([] as Relation[]).concat(...schemaTables),
    hasCustomTypes = Object.keys(customTypes).length > 0,
    schemaInterface = generateSchemaInterface(allTables, config.unprefixedSchema),
    // Generate explicit exports instead of ambient declarations
    ts = header() +
      `import type * as db from '@architect-eng/sapatos/db';\n` +
      (hasCustomTypes ? `import type * as c from './custom';\n` : ``) +
      versionCanary + '\n\n' +
      schemaDefs.join('\n\n') +
      `\n\n/* === Schema interface === */\n` +
      schemaInterface +
      `\n/* === global aggregate types === */\n` +
      crossSchemaTypesForSchemas(schemaNames) +
      `\n\n/* === lookups === */\n` +
      crossSchemaTypesForAllTables(allTables, config.unprefixedSchema),
    customTypeSourceFiles = sourceFilesForCustomTypes(customTypes);

  await pool.end();
  return { ts, customTypeSourceFiles };
};
